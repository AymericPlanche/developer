[{"project":"index.md","title":"Fermyon Developer Home","subheading":"","content":"This is a placeholder for Fermyon Developer Home","url":"/index.md"},{"project":"spin","title":"Spin architecture and internals","subheading":"","content":"This document aims to offer an overview to the implementation of Spin, as well\nas explain how the code is structured and how all parts fit together. This\ndocument is continuously evolving, and if you want even more detailed\ninformation, make sure to review the code for a given part of Spin.","url":"/spin/architecture.md"},{"project":"spin","title":"Spin architecture and internals","subheading":"How Spin runs an application","content":"A Spin application is defined as a spin.toml file. It can either be run\ndirectly by spin up, passing the manifest file (--file spin.toml), or it can\nbe pushed to the registry then referenced using its remote ID\n(spin bindle push followed by spin up --bindle <id>).Regardless of the application origin (local file or remote reference from the\nregistry), a Spin application is defined by\nspin_manifest::Application (contained in the\nundefined crate),\nwhich is the canonical representation of a Spin application.The crate responsible for transforming a custom configuration into a canonical\nSpin application is undefined,\nwhich implements loading applications from local spin.toml files and from\nremote Bindle references (and ensures files referenced in the application\nconfiguration are copied and mounted at the location expected in the WebAssembly\nmodule). Once the canonical representation is loaded from an application source,\nit is passed to a trigger.The HTTP trigger (defined in the spin-http crate) takes an\napplication configuration (undefined\nexplores a trigger handling multiple applications), starts an HTTP listener, and\nfor each new request, it routes it to the component configured in the\napplication configuration. Then, it instantiates the WebAssembly module (using a\nspin_engine::ExecutionContext) and uses the appropriate executor (either the\nSpinHttpExecutor or the WagiHttpExecutor, based on the component\nconfiguration) to handle the request and return the response.","url":"/spin/architecture.md#how-spin-runs-an-application"},{"project":"spin","title":"Spin architecture and internals","subheading":"The Spin execution context","content":"The Spin execution context (or \"Spin engine\") is the part of Spin that executes\nWebAssembly components using the\nundefined WebAssembly runtime. It\nis implemented in the spin-engine crate, and serves as\nthe part of Spin that takes a fully formed application configuration and creates\nWasm instances based on the component configurations.There are two important concepts in this crate:undefinedundefined","url":"/spin/architecture.md#the-spin-execution-context"},{"project":"spin","title":"Configuration for Spin applications","subheading":"","content":"Spin applications are comprised of general information (metadata), and a collection\nof at least one undefined. Configuration for a Spin application lives in a TOML\nfile called spin.toml (the undefined). In the example below we can see\na simple HTTP application with a single component executed when the /hello endpoint\nis accessed:spin_version = \"1\"\nname = \"spin-hello-world\"\ndescription = \"A simple application that returns hello world.\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\ndescription = \"A simple component that returns hello world.\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"","url":"/spin/configuration.md"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Application manifest reference","content":"","url":"/spin/configuration.md#application-manifest-reference"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Application configuration","content":"The following are the fields supported by the spin.toml manifest file:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/configuration.md#application-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Component configuration","content":"Each component object has the following fields:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/configuration.md#component-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Custom Configuration","content":"Spin applications may define custom configuration which can be looked up by\ncomponent code via the undefined.","url":"/spin/configuration.md#custom-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Custom Config Variables","content":"Application-global custom config variables are defined in the top-level [variables]\nsection. These entries aren't accessed directly by components, but are referenced\nby undefined value templates. Each entry must\neither have a default value or be marked as required = true. \"Required\" entries\nmust be undefined with a value.Configuration keys may only contain lowercase letters and underscores between letters.[variables]\napi_host = { default = \"api.example.com\" }\napi_key = { required = true }","url":"/spin/configuration.md#custom-config-variables"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Component Custom Config","content":"The configuration entries available to a component are listed in its\n[component.config] section. Configuration values may reference\nundefined with simple\nundefined-inspired string templates.[[component]]\n# ...\n[component.config]\napi_base_url = \"https://{{ api_host }}/v1\"\napi_key = \"{{ api_key }}\"","url":"/spin/configuration.md#component-custom-config"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Custom Config Providers","content":"undefined values may be set at runtime by\nconfig \"providers\". Currently there is only one provider: the environment\nvariable provider, which gets config values from the spin process's\nenvironment (undefined the component environment). Config keys are translated\nto environment variables by upper-casing and prepending with SPIN_APP_:$ export SPIN_APP_API_KEY = \"1234\"  # Sets the `api_key` value.\n$ spin up","url":"/spin/configuration.md#custom-config-providers"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Examples","content":"undefined[[component]]\nsource = \"modules/spin_static_fs.wasm\"\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"undefined[[component]]\nsource = \"modules/env_wagi.wasm\"\nid = \"env\"\nfiles = [ \"content/**/*\" , \"templates/*\", \"scripts/*\", \"config/*\"]\n[component.trigger]\nroute = \"/...\"\nexecutor = { type = \"wagi\", argv = \"test ${SCRIPT_NAME} ${ARGS} done\", entrypoint = \"some-other-export-function\" }undefined[[component]]\nid = \"echo-message\"\nsource = \"spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"","url":"/spin/configuration.md#examples"},{"project":"spin","title":"Contributing to Spin","subheading":"","content":"We are delighted that you are interested in making Spin better! Thank you! This\ndocument will guide you through making your first contribution to the project.First, any contribution and interaction on any Fermyon project MUST follow our\nundefined. Thank you for being\npart of an inclusive and open community!\nWe welcome and appreciate contributions of all types — opening issues, fixing\ntypos, adding examples, one-liner code fixes, tests, or complete features.If you plan on contributing anything complex, please go through the issue and PR\nqueues first to make sure someone else has not started working on it. If it\ndoesn't exist already, please open an issue so you have a chance to get feedback\nfrom the community and the maintainers before you start working on your feature.","url":"/spin/contributing.md"},{"project":"spin","title":"Contributing to Spin","subheading":"Making code contributions to Spin","content":"The following guide is intended to make sure your contribution can get merged as\nsoon as possible. First, make sure you have the following prerequisites\nconfigured:undefinedundefinedundefinedundefinedundefinedundefinedOnce you have set up the prerequisites and identified the contribution you want\nto make to Spin, make sure you can correctly build the project:# clone the repository\n$ git clone https://github.com/fermyon/spin && cd spin\n# add a new remote pointing to your fork of the project\n$ git remote add fork https://github.com/<your-username>/spin\n# create a new branch for your work\n$ git checkout -b <your-branch>\n\n# if you are making a documentation contribution,\n# you can skip compiling and running the tests.\n\n# build a release version of the Spin CLI\n$ cargo build --release\n# make sure compilation is successful\n$ ./target/release/spin --help\n\n# run the tests and make sure they pass\n$ make testNow you should be ready to start making your contribution. To familiarize\nyourself with the Spin project, please read the\nundefined. Since most of Spin is implemented in\nRust, we try to follow the common Rust coding conventions (keep an eye on the\nrecommendations from Clippy!) If applicable, add unit or integration tests to\nensure your contribution is correct.Build the project and run the tests (make build test), and if everything is\nsuccessful, you should be ready to commit your changes. We try to follow the\nundefined\nguidelines for writing commit messages:$ git commit -S -s -m \"<your commit message that follows https://www.conventionalcommits.org/en/v1.0.0/>\"We try to only keep useful changes as separate commits — if you prefer to commit\noften, please\nundefined\nbefore opening a pull request. Once you are happy with your changes you can push\nthe branch to your fork:# \"fork\" is the name of the git remote pointing to your fork\n$ git push forkNow you are ready to create a pull request. Thank you for your contribution!","url":"/spin/contributing.md#making-code-contributions-to-spin"},{"project":"spin","title":"Deploying Spin applications to Fermyon","subheading":"","content":"undefined is the frictionless WebAssembly platform for deploying\nmicroservices and web apps. With Fermyon, you can deploy your spin applications onto a server in\nmoments.For instructions guiding you through running the Fermyon platform on your development workstation,\nfollow undefined.For instructions guiding you through running the Fermyon platform on AWS, follow\nundefined.","url":"/spin/deploying-to-fermyon.md"},{"project":"spin","title":"Developing Spin applications","subheading":"","content":"The Spin CLI offers a few commands to simplify developing applications.","url":"/spin/developing.md"},{"project":"spin","title":"Developing Spin applications","subheading":"Building Spin applications","content":"A Spin application is made up of one or more components. When developing a\nmulti-component application, it is very common to have multiple directories with\nsource code for components — and when making changes to components, having to\nmanually go into the each component directory, compile the component, then go\nback to the directory with spin.toml can be a very repetitive task.This is why Spin has a top-level command that will execute the build command\nset by each component, spin up:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release --manifest-path http-rust/Cargo.toml\"Then, running spin build will execute, sequentially, each build command:$ RUST_LOG=spin=trace spin build\n2022-04-25T03:01:56.721630Z  INFO spin_build: Executing the build command for component rust-hello.\n    Finished release [optimized] target(s) in 0.05s\n2022-04-25T03:01:56.832360Z  INFO spin_build: Executing the build command for component rust-static-assets.\n    Finished release [optimized] target(s) in 0.02s\n2022-04-25T03:01:56.905424Z  INFO spin_build: Executing the build command for component rust-outbound-http.\n    Finished release [optimized] target(s) in 0.02sThe spin build command is intended to offer a built-in way to build more complex\nSpin applications without needing a separate build process.\nIt is not intended to replace complex build scripts — if\nyou have existing automated ways for building source code, those can be used\ninstead, or the build command can call that process.spin build --up can be used to start the application after the build process\nfinishes for all application components.","url":"/spin/developing.md#building-spin-applications"},{"project":"spin","title":"Developing Spin applications","subheading":"Component  workdir","content":"By default, the command to build a component is executed in the manifest's\ndirectory. This can be changed. For example, assume a component is located in\nsubdirectory deep:.\n├── deep\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo run the build command in directory deep, set the component's workdir:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"deep\"Note that workdir must be a relative path and it operates relative to the\nspin.toml. Specifying an absolute path leads to an error.","url":"/spin/developing.md#component-workdir"},{"project":"spin","title":"Packaging and distributing Spin applications","subheading":"","content":"Packaging and distributing Spin applications is done using undefined,\nan open source aggregate object storage system. This allows the packaging of the\napplication manifest, components, and static assets together, and\ntakes advantage of the features of a modern object storage system.To distribute applications, we first need a Bindle registry. You can\nundefined,\nor use the\nundefined\nVS Code extension (through the Bindle: Start command):$ bindle-server --address 127.0.0.1:8000 --directory . --unauthenticatedLet's push the application from the undefined to the registry:$ export BINDLE_URL=http://localhost:8000/v1\n$ spin bindle push --file spin.toml\npushed: spin-hello-world/1.0.0Now we can run the application using spin up directly from the registry:$ spin up --bindle spin-hello-world/1.0.0undefinedThe application can also be prepared in a local directory before pushing to the\nregistry by running spin bindle prepare.","url":"/spin/distributing-apps.md"},{"project":"spin","title":"Extending and embedding Spin","subheading":"","content":"undefinedSpin currently implements triggers and application models for:undefinedundefinedThe Spin internals and execution context (the part of Spin executing\ncomponents) are agnostic of the event source and application model.\nIn this document we will explore how to extend Spin with custom event sources\n(triggers) and application models built on top of the WebAssembly component\nmodel, as well as how to embed Spin in your application.In this article we will build a Spin trigger to run the applications based on a\ntimer, executing Spin components at configured time interval.The current application types that can be implemented with Spin have entry points\ndefined using\nundefined:// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> response\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>The entry point we want to execute for our timer trigger takes a string as its\nonly argument (the trigger will populate that with the current date and time),\nand it expects a string as the only return value. This is purposefully chosen\nto be a simple function signature:// examples/spin-timer/spin-timer.wit\nhandle-timer-request: function(msg: string) -> stringThis is the function that all components executed by the timer trigger must\nimplement, and which is used by the timer executor when instantiating and\ninvoking the component.Let's have a look at building the timer trigger:// examples/spin-timer/src/main.rs\nwit_bindgen_wasmtime::import!({paths: [\"spin-timer.wit\"], async: *});\ntype ExecutionContext = spin_engine::ExecutionContext<spin_timer::SpinTimerData>;\n\n/// A custom timer trigger that executes a component on every interval.\n#[derive(Clone)]\npub struct TimerTrigger {\n    /// The interval at which the component is executed.\n    pub interval: Duration,\n    /// The Spin execution context.\n    engine: Arc<ExecutionContext>,\n}A few important things to note from the start:undefinedundefinedundefinedFinally, whenever there is a new event (in the case of our timer-based trigger\nevery n seconds), we execute the entry point of a selected component:/// Execute the first component in the application manifest.\nasync fn handle(&self, msg: String) -> Result<()> {\n    // create a new Wasmtime store and instance based on the first component's WebAssembly module.\n    let (mut store, instance) =\n        self.engine\n            .prepare_component(&self.app.components[0].id, None, None, None, None)?;\n\n    // spawn a new thread and call the entry point function from the WebAssembly module \n    let res = spawn_blocking(move || -> Result<String> {\n            // use the auto-generated WIT bindings to get the Wasm exports and call the `handle-timer-request` function.\n        let t = spin_timer::SpinTimer::new(&mut store, &instance, |host| {\n            host.data.as_mut().unwrap()\n        })?;\n        Ok(t.handle_timer_request(&mut store, &msg)?)\n    })\n    .await??;\n    // do something with the result.\n    log::info!(\"{}\\n\", res);\n    Ok(())\n}A few notes:undefinedundefinedundefinedThis is very similar to how the undefined and undefined\ntriggers are implemented, and it is the recommended way to extend Spin with your\nown trigger and application model.Writing components for the new trigger can be done by using the\nundefined from\nRust and other supported languages (see undefined):// automatically generate Rust bindings that help us implement the \n// `handle-timer-request` function that the trigger will execute.\nwit_bindgen_rust::export!(\"../spin-timer.wit\");\n...\nfn handle_timer_request(msg: String) -> String {\n    format!(\"ECHO: {}\", msg)\n}Components can be compiled to WebAssembly, then used from a spin.toml\napplication manifest.Embedding the new trigger in a Rust application is done by creating a new trigger\ninstance, then calling its run function:// app() is a utility function that generates a complete application configuration.\nlet trigger = TimerTrigger::new(Duration::from_secs(1), app()).await?;\n// run the trigger indefinitely\ntrigger.run().awaitundefinedIn this example, we built a simple timer trigger — building more complex triggers\nwould also involve updating the Spin application manifest, and extending\nthe application-level trigger configuration, as well as component-level\ntrigger configuration (an example of component-level trigger configuration\nfor this scenario would be each component being able to define its own\nindependent time interval for scheduling the execution).","url":"/spin/extending-and-embedding.md"},{"project":"spin","title":"Extending and embedding Spin","subheading":"Other ways to extend and use Spin","content":"Besides building custom triggers, the internals of Spin could also be used\nindependently:undefinedundefined","url":"/spin/extending-and-embedding.md#other-ways-to-extend-and-use-spin"},{"project":"spin","title":"Building Spin components in Go","subheading":"","content":"undefined is an implementation of the\nundefined for embedded systems and WebAssembly.\nThe Spin SDK for Go uses\nundefined\nto build programs written in Go as Spin components.undefinedundefined","url":"/spin/go-components.md"},{"project":"spin","title":"Building Spin components in Go","subheading":"Versions","content":"TinyGo currently requires Go versions 1.15.x through 1.17.x. The recommendation is to use\nGo version 1.17.9, and TinyGo version 0.22.0. Go 1.18.x support will be added in an upcoming\nTinyGo release 0.22.x.","url":"/spin/go-components.md#versions"},{"project":"spin","title":"Building Spin components in Go","subheading":"HTTP components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Go has improved support for\nwriting applications, through its SDK.Building a Spin HTTP component using the Go SDK means writing a single function,\ninit — below is a complete implementation for such a component:// A Spin component written in Go that returns \"Hello, Fermyon!\"\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"text/plain\")\n  fmt.Fprintln(w, \"Hello Fermyon!\")\n })\n}\n\nfunc main() {}The important things to note in the implementation above:undefinedundefinedundefined","url":"/spin/go-components.md#http-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Sending outbound HTTP requests","content":"If allowed, Spin components can send outbound requests to HTTP endpoints. Let's\nsee an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:// A Spin component written in Go that sends a request to an API\n// with random dog facts.\n\npackage main\n\nimport (\n \"bytes\"\n \"fmt\"\n \"net/http\"\n \"os\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  r, _ := spinhttp.Get(\"https://some-random-api.ml/facts/dog\")\n\n  fmt.Fprintln(w, r.Body)\n  fmt.Fprintln(w, r.Header.Get(\"content-type\"))\n\n  // `spin.toml` is not configured to allow outbound HTTP requests to this host,\n  // so this request will fail.\n  if _, err := spinhttp.Get(\"https://fermyon.com\"); err != nil {\n   fmt.Fprintf(os.Stderr, \"Cannot send HTTP request: %v\", err)\n  }\n })\n}\n\nfunc main() {}The component can be built using the tingygo toolchain:$ tinygo build -wasm-abi=generic -target=wasi -no-debug -o main.wasm main.goBefore we can execute this component, we need to add the\nsome-random-api.ml domain to the application manifest allowed_http_hosts\nlist containing the list of domains the component is allowed to make HTTP\nrequests to:# spin.toml\nspin_version = \"1\"\nname = \"spin-hello-tinygo\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"tinygo-hello\"\nsource = \"main.wasm\"\nallowed_http_hosts = [ \"some-random-api.ml\" ]\n[component.trigger]\nroute = \"/hello\"undefinedRunning the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ncontent-type: text/plain; charset=utf-8\nserver: spin/0.1.0\ncontent-length: 85\ndate: Fri, 18 Mar 2022 23:27:33 GMT\n\n{{\"fact\":\"Seventy percent of people sign their dog's name on their holiday cards.\"}}undefinedundefined","url":"/spin/go-components.md#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin components in Go","subheading":"Redis components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger, which\nwill connect to a Redis instance and will execute components for new messages\non the configured channels.undefinedWriting a Redis component in Go also takes advantage of the SDK:package main\n\nimport (\n \"fmt\"\n\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // redis.Handle() must be called in the init() function.\n redis.Handle(func(payload []byte) error {\n  fmt.Println(\"Payload::::\")\n  fmt.Println(string(payload))\n  return nil\n })\n}\n\n// main function must be included for the compiler but is not executed.\nfunc main() {}The manifest for a Redis application must contain the address of the Redis instance:spin_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"main.wasm\"\n[component.trigger]\nchannel = \"messages\"\n[component.build]\ncommand = \"tinygo build -wasm-abi=generic -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"The application will connect to redis://localhost:6379, and for every new message\non the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin build --up\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component:INFO spin_redis_engine: Received message on channel \"messages\"\nPayload::::\nHello, there!","url":"/spin/go-components.md#redis-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Storing data in Redis from Go components","content":"Using the Spin's Go SDK, you can use the Redis key/value store to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Go SDK to connect to Redis:package main\n\nimport (\n \"net/http\"\n \"os\"\n\n spin_http \"github.com/fermyon/spin/sdk/go/http\"\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // handler for the http trigger\n spin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n  // addr is the environment variable set in `spin.toml` that points to the\n  // address of the Redis server.\n  addr := os.Getenv(\"REDIS_ADDRESS\")\n\n  // channel is the environment variable set in `spin.toml` that specifies\n  // the Redis channel that the component will publish to.\n  channel := os.Getenv(\"REDIS_CHANNEL\")\n\n  // payload is the data publish to the redis channel.\n  payload := []byte(`Hello redis from tinygo!`)\n\n  if err := redis.Publish(addr, channel, payload); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // set redis `mykey` = `myvalue`\n  if err := redis.Set(addr, \"mykey\", []byte(\"myvalue\")); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // get redis payload for `mykey`\n  if payload, err := redis.Get(addr, \"mykey\"); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n  } else {\n   w.Write([]byte(\"mykey value was: \"))\n   w.Write(payload)\n  }\n })\n}\n\nfunc main() {}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","url":"/spin/go-components.md#storing-data-in-redis-from-go-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Using Go packages in Spin components","content":"Any\nundefined that can be imported in TinyGo and that compiles to\nWASI can be used when implementing a Spin component.undefined","url":"/spin/go-components.md#using-go-packages-in-spin-components"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"","content":"An important workload in event-driven environments is represented by HTTP\napplications, and Spin has built-in support for creating and running HTTP\ncomponents. This document presents an overview of the HTTP trigger, as well as\nsome implementation details around the WebAssembly component model and how it\nis used in Spin.The HTTP trigger in Spin is a web server. It listens for incoming requests and\nbased on the undefined, it routes them to an\nundefined which instantiates the appropriate component, executes its\nentry point function, then returns an HTTP response.Creating an HTTP application is done when undefined\nby defining the top-level application trigger:# spin.toml\ntrigger = { type = \"http\", base = \"/\" }Then, when defining the component (in spin.toml), there are two pieces of\nconfiguration that can be set for the component trigger: the route,\nand the undefined (see details below about executors). For example:undefined[component.trigger]\nroute = \"/hello\"\nexecutor = { type = \"spin\" }undefined[component.trigger]\nroute = \"/goodbye\"\nexecutor = { type = \"wagi\" }","url":"/spin/http-trigger.md"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"Routing","content":"Routing an incoming request to a particular component is done using the\napplication base path (base in spin.toml) and the component defined routes\n(route in the component configuration) by prefixing the application base path\nto all component routes defined for that application.For example, if the application base path is base = /base, and a component\nhas defined route = /foo, that component will be executed for requests on\nhttp(s)://<spin-up-defined-address-and-port>/base/foo.Components can either define exact routes, for example route = /bar/baz, where\nthe component will be invoked only for requests on /base/bar/baz, or they\ncan define a wildcard as the last path segment, for example route = /bar/baz/...,\nwhich means the component will be invoked for every request starting with the\n/base/bar/baz/ prefix (such as /base/bar/baz, /base/bar/baz/qux,\n/base/bar/baz/qux/quux and so on).If multiple components could potentially handle the same request based on their\ndefined routes, the last component defined in spin.toml takes precedence.\nIn the following example:# spin.toml\n\ntrigger = { type = \"http\", base = \"/\"}\n\n[[component]]\nid = \"component-1\"\n[component.trigger]\nroute = \"/...\"\n\n[[component]]\nid = \"component-2\"\n[component.trigger]\nroute = \"/foo/...\"Any request starting with the  /foo/ prefix  will be handled by component-2,\nwhich is the last one defined in spin.toml.Every HTTP application has a special route always configured at /healthz, which\nreturns OK 200 when the Spin instance is healthy.Once Spin selects a component to handle an incoming request based on the route\nconfiguration, it will instantiate and execute that component based on its\ndefined undefined, and the next sections explore the two ways of building\nHTTP components based on the two available executors.","url":"/spin/http-trigger.md#routing"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The Spin HTTP executor","content":"Spin is built on top of the\nundefined.\nWe undefined believe the component model represents the future of WebAssembly,\nand we are working with the undefined\ncommunity on building exciting new features and tools for it. As a result, the\nSpin HTTP undefined is defined using WebAssembly interfaces.undefinedWe define the HTTP objects as\nundefined\nobjects, currently using undefined:// wit/ephemeral/http-types.wit\n\n// The HTTP status code.\ntype http-status = u16\n// The HTTP body.\ntype body = list<u8>\n// The HTTP headers represented as a list of (name, value) pairs.\ntype headers = list<tuple<string, string>>\n// The HTTP parameter queries, represented as a list of (name, value) pairs.\ntype params = list<tuple<string, string>>\n// The HTTP URI of the current request.\ntype uri = string\n// The HTTP method.\nenum method { get, post, put,... }\n\n// An HTTP request.\nrecord request {\n    method: method,\n    uri: uri,\n    headers: headers,\n    params: params,\n    body: option<body>,\n}\n\n// An HTTP response.\nrecord response {\n    status: http-status,\n    headers: option<headers>,\n    body: option<body>,\n}undefinedThen, we define the entry point for a Spin HTTP component:// wit/ephemeral/spin-http.wit\n\nuse * from http-types\n// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> responseThis is the function signature that all HTTP components must implement, and\nwhich is used by the Spin HTTP executor when instantiating and invoking the\ncomponent.\nThis interface (spin-http.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.\nThis is exactly how undefined is built, and,\nas more languages add support for the component model, how we plan to add\nsupport for them as well.","url":"/spin/http-trigger.md#the-spin-http-executor"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The Wagi HTTP executor","content":"The WebAssembly component model proposal is currently in its early stages, which\nmeans only a few programming languages fully implement it. While the language\ncommunities implement toolchain support for the component model (for emitting\ncomponents and for automatically generating bindings for importing other\ncomponents), we want to allow developers to use any language that compiles to\nWASI to build Spin HTTP applications. This is why Spin currently implements an\nHTTP executor based on undefined, or the\nWebAssembly Gateway Interface, a project that implements the\nundefined\nspecification for WebAssembly.undefinedWagi allows a module built in any programming language that compiles to undefined\nto handle an HTTP request by passing the HTTP request information to the module's\nstandard input, environment variables, and arguments, and expecting the HTTP\nresponses through the module's standard output.\nThis means that if a language has support for the WebAssembly System Interface,\nit can be used to build Spin HTTP components.\nThe Wagi model is only used to parse the HTTP request and response. Everything\nelse — defining the application, running it, or undefined\nis done the same way as a component that uses the Spin executor.Building a Wagi component in a particular programming language that can compile\nto wasm32-wasi does not require any special libraries — instead,\nundefined can\nbe done by reading the HTTP request from the standard input and environment\nvariables, and sending the HTTP response to the module's standard output.In pseudo-code, this is the minimum required in a Wagi component:undefinedundefinedundefinedprint(\"content-type: text/html; charset=UTF-8\\n\\n\");\nprint(\"hello world\\n\");The undefined supports the Spin executor.\nHere is another example, written in undefined,\na new programming language that natively targets WebAssembly:import Process from \"sys/process\";\nimport Array from \"array\";\n\nprint(\"content-type: text/plain\\n\");\n\n// This will print all the Wagi env variables\nprint(\"==== Environment: ====\");\nArray.forEach(print, Process.env());\n\n// This will print the route path followed by each query\n// param. So /foo?bar=baz will be [\"/foo\", \"bar=baz\"].\nprint(\"==== Args: ====\");\nArray.forEach(print, Process.argv());undefined","url":"/spin/http-trigger.md#the-wagi-http-executor"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The default headers set in Spin HTTP components","content":"Spin sets a few default headers on the request based on the base path, component\nroute, and request URI, which will always be available when writing a module:undefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/http-trigger.md#the-default-headers-set-in-spin-http-components"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The default headers set in Wagi HTTP components","content":"For Wagi HTTP components, the following are set as environment variables for the\nhandler WebAssembly modules:undefinedundefinedundefinedundefinedundefinedundefinedBesides the headers above, components that use the Wagi executor also have set\nundefined.","url":"/spin/http-trigger.md#the-default-headers-set-in-wagi-http-components"},{"project":"spin","title":"Introducing Spin","subheading":"","content":"Spin is a framework for building and running event-driven microservice applications\nwith WebAssembly (Wasm) components. With Spin, we’re trying to make it easier to get\nstarted with using WebAssembly on the server so that we can all take advantage of the\nsecurity, portability, and speed WebAssembly provides when it comes to running\nmicroservices.","url":"/spin/index.md"},{"project":"spin","title":"Introducing Spin","subheading":"Structure of a Spin Application","content":"undefinedundefinedSpin executes the component(s) as a result of events being generated by the trigger(s)\ndefined in the spin.toml file.","url":"/spin/index.md#structure-of-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Example Spin Application","content":"The following illustrates how to define an HTTP application.","url":"/spin/index.md#example-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"HTTP Handler","content":"This hello_world function written in Rust defines a component that takes a Request and returns a Result<Response>.#[http_component]​\nfn hello_world(_req: Request) -> Result<Response> {​\n    Ok(http::Response::builder()​\n        .status(200)​\n        .body(Some(\"Hello, Fermyon!\".into()))?)​\n}​","url":"/spin/index.md#http-handler"},{"project":"spin","title":"Introducing Spin","subheading":"Spin Manifest","content":"Once the code is compiled to a WebAssembly component, it can be referenced in a spin.toml\nfile to create an HTTP application like what you can see below:spin_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"<path to compiled Wasm module>\"\n[component.trigger]\nroute = \"/hello\"","url":"/spin/index.md#spin-manifest"},{"project":"spin","title":"Introducing Spin","subheading":"Running a Spin Application","content":"Running this application with the spin CLI is as simple as using the spin up command.\nBecause a trigger type of http is specified in the spin.toml file, spin up will start\na web server:$ spin up\nServing HTTP on address http://127.0.0.1:3000\nAvailable Routes:\n  hello: http://127.0.0.1:3000/helloAny time a request is made on the /hello route, it will invoke the\nhello_world function. Adding another component is as simple as adding another [[component]]\nstanza to the spin.toml file.In the next section, we will undefined.","url":"/spin/index.md#running-a-spin-application"},{"project":"spin","title":"Building Spin components in other languages","subheading":"","content":"undefinedundefinedWebAssembly is becoming undefined, and as language toolchains add support for the\nundefined,\nbuilding Spin components will also become supported.As a general rule:undefinedundefinedundefinedundefined","url":"/spin/other-languages.md"},{"project":"spin","title":"Building Spin components in other languages","subheading":"AssemblyScript","content":"undefined is a TypeScript-based language that compiles directly to WebAssembly.\nAssemblyScript has WASI/Wagi support, and so can be used with Spin.undefinedundefinedundefined","url":"/spin/other-languages.md#assemblyscript"},{"project":"spin","title":"Building Spin components in other languages","subheading":"C/C++","content":"C and C++ are both broadly supported in the WebAssembly ecosystem. WASI/Wagi support means that both can be used to write Spin apps.undefinedundefinedundefined","url":"/spin/other-languages.md#cc"},{"project":"spin","title":"Building Spin components in other languages","subheading":"C# and .NET languages","content":".NET has experimental support for WASI, so many (if not all) .NET languages, including C# and F#, can be used to write Spin applications.undefinedundefined","url":"/spin/other-languages.md#c-and-net-languages"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Grain","content":"undefined, a new functional programming language, has WASI/Wagi support and can be used to write Spin apps.undefinedundefinedundefined","url":"/spin/other-languages.md#grain"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Python","content":"Python's interpreter can be compiled to WebAssembly, and it has WASI support. It is known to work for Spin.undefinedundefinedundefinedundefinedundefined","url":"/spin/other-languages.md#python"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Ruby","content":"Upstream undefined officially supports WebAssembly and WASI, and we here at Fermyon have successfully run Ruby apps in Spin.undefinedundefined","url":"/spin/other-languages.md#ruby"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Zig","content":"Zig is a low-level systems language that has support for Wasm and WASI, and can be used to write Spin apps.undefinedundefined","url":"/spin/other-languages.md#zig"},{"project":"spin","title":"Taking Spin for a spin","subheading":"","content":"undefined","keywords":"quickstart","url":"/spin/quickstart.md"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Getting the  spin  binary","content":"You can install the spin binary using the install.sh script hosted on this site.$ curl https://spin.fermyon.dev/downloads/install.sh | bashTo install a specific version, you can pass arguments to the install script this way:$ curl https://spin.fermyon.dev/downloads/install.sh | bash -s -- -v v0.5.0To install canary version of spin, you should pass the argument -v canary$ curl https://spin.fermyon.dev/downloads/install.sh | bash -s -- -v canaryAt this point, move the spin binary somewhere in your path, so it can be\naccessed from any directory. For example:$ sudo mv ./spin /usr/local/bin/spin","keywords":"quickstart","url":"/spin/quickstart.md#getting-the-spin-binary"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Alternative 1: Building Spin from source","content":"undefined for a detailed guide\non building Spin from source:$ git clone https://github.com/fermyon/spin\n$ cd spin && make build\n$ ./target/release/spin --help","keywords":"quickstart","url":"/spin/quickstart.md#alternative-1-building-spin-from-source"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Alternative 2: Using Cargo to install Spin","content":"If you have undefined, you can clone the repo and install it to your path:$ git clone https://github.com/fermyon/spin -b v0.5.0\n$ cd spin\n$ rustup target add wasm32-wasi\n$ cargo install --locked --path .\n$ spin --help","keywords":"quickstart","url":"/spin/quickstart.md#alternative-2-using-cargo-to-install-spin"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Linux: Additional Libraries","content":"On a fresh Linux installation, you will also need the standard build toolchain\n(gcc, make, etc.), the SSL library headers, and on some distributions you\nmay need pkg-config.On Debian-like distributions, including Ubuntu, you can install these with a\ncommand like this:$ sudo apt-get install build-essential libssl-dev pkg-config","keywords":"quickstart","url":"/spin/quickstart.md#linux-additional-libraries"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Creating a new Spin application from a template","content":"Spin helps you create a new application based on templates:$ spin templates list\nYou have no templates installed. Run\nspin templates install --git https://github.com/fermyon/spin\nto install a starter set.We first need to configure the undefined:$ spin templates install --git https://github.com/fermyon/spin\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\nInstalling template http-go...\n+--------------------------------------------------+\n| Name         Description                         |\n+==================================================+\n| http-go      HTTP request handler using (Tiny)Go |\n| http-rust    HTTP request handler using Rust     |\n| redis-rust   Redis message handler using Rust    |\n| ...                                              |\n+--------------------------------------------------+undefinedLet's create a new Spin application based on the Rust HTTP template:$ spin new http-rust spin-hello-world\nProject description: A simple Spin HTTP component in Rust\nHTTP base: /\nHTTP path: /hello\n$ tree\n├── .cargo\n│   └── config.toml\n├── .gitignore\n├── Cargo.toml\n├── spin.toml\n└── src\n    └── lib.rsThis command created all the necessary files we need to build and run our first\nSpin application. Here is spin.toml, the manifest file for a Spin application:spin_version = \"1\"\ndescription = \"A simple Spin HTTP component in Rust\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"spin-hello-world\"\nsource = \"target/wasm32-wasi/release/spin_hello_world.wasm\"\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called spin-hello-world. Spin will execute the spin_hello_world.wasm\nWebAssembly module for HTTP requests on the route /hello.\n(See the undefined for a detailed guide on the Spin\napplication manifest.)Now let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Rust — a regular Rust function that\ntakes an HTTP request as a parameter and returns an HTTP response, and it is\nannotated with the http_component macro:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn spin_hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon\".into()))?)\n}undefinedFor Rust templates you need the wasm32-wasi target. You can add it using rustup:rustup target add wasm32-wasi.For TinyGo templates you need the undefined.We can build this component using the regular Rust toolchain, targeting\nwasm32-wasi, which will produce the WebAssembly module and place it at\ntarget/wasm32-wasi/release/spinhelloworld.wasm as referenced in the\nspin.toml. For convenience, we can use the spin build command, which will\nexecute the command defined above in spin.toml and call the Rust toolchain:$ spin build\nExecuting the build command for component spin-hello-world: cargo build --target wasm32-wasi --release\n   Compiling spin_hello_world v0.1.0\n    Finished release [optimized] target(s) in 0.10s\nSuccessfully ran the build command for the Spin components.undefinedundefinedIf you run into errors, you might want to use rustup check to see if your Rust installation is up-to-date.","keywords":"quickstart","url":"/spin/quickstart.md#creating-a-new-spin-application-from-a-template"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Running the application with  spin up","content":"Now that we configured the application and built our component, we can undefined\nthe application (pun intended):$ spin up\nServing HTTP on address http://127.0.0.1:3000\nAvailable Routes:\n  spin-hello-world: http://127.0.0.1:3000/helloOptionally, set the RUST_LOG environment variable for detailed logs, before running spin up.$ export RUST_LOG=spin=traceSpin will instantiate all components from the application manifest, and\nwill create the router configuration for the HTTP trigger accordingly. The\ncomponent can now be invoked by making requests to http://localhost:3000/hello\n(see route field in the configuration):$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\nfoo: bar\ncontent-length: 15\n\nHello, Fermyon!You can add as many components as needed in spin.toml, mount files and\ndirectories, allow granular outbound HTTP connections, or set environment variables\n(see the undefined for a detailed guide on\nthe Spin application manifest) and iterate locally with\nspin up --file spin.toml until you are ready to distribute the application.Congratulations! You just completed building and running your first Spin\napplication!\nNext, check out the undefined or undefined language\nguides, or have a look at undefined.","keywords":"quickstart","url":"/spin/quickstart.md#running-the-application-with-spin-up"},{"project":"spin","title":"The Spin Redis trigger","subheading":"","content":"Spin applications can be triggered by a new message on a undefined.\nSpin will connect to a configured Redis instance and will invoke components for\nnew messages on the configured channels.undefinedThe Redis instance address is specified in the application trigger:# spin.toml\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }undefinedThen, all components in the application are triggered when new messages are\npublished to channels in the instance. undefined the channel\nis done by setting the channel field in the component trigger configuration.[component.trigger]\nchannel = \"messages\"","url":"/spin/redis-trigger.md"},{"project":"spin","title":"The Spin Redis trigger","subheading":"The WebAssembly interface","content":"The Redis trigger is built on top of the\nundefined.\nThe current interface is defined using the\nundefined\nformat, and is a function that takes the message payload as its only parameter:// wit/ephemeral/spin-redis.wit\n\n// The message payload.\ntype payload = list<u8>\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>undefinedThis is the function that all Redis components must implement, and which is\nused by the Spin Redis executor when instantiating and invoking the component.\nThis interface (spin-redis.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.\nThis is exactly how undefined is built, and,\nas more languages add support for the component model, how we plan to add\nsupport for them as well.undefined","url":"/spin/redis-trigger.md#the-webassembly-interface"},{"project":"spin","title":"Creating a new Spin release","subheading":"","content":"To cut a release of Spin, you will need to do the following:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedAt this point, you can verify in the GitHub UI that the release was successful.","url":"/spin/release-process.md"},{"project":"spin","title":"Building Spin components in Rust","subheading":"","content":"Spin aims to have best-in-class support for building components in Rust, and\nwriting such components should be familiar for Rust developers.undefinedundefinedIn order to compile Rust programs to Spin components, you also need the\nwasm32-wasi target. You can add it using rustup:$ rustup target add wasm32-wasi","url":"/spin/rust-components.md"},{"project":"spin","title":"Building Spin components in Rust","subheading":"HTTP components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, but Rust has improved support\nfor writing Spin components with the Spin Rust SDK.undefinedBuilding a Spin HTTP component using the Rust SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req);\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon!\".into()))?)\n}The important things to note in the implementation above:undefinedundefinedundefined","url":"/spin/rust-components.md#http-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Sending outbound HTTP requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:#[http_component]\nfn hello_world(_req: Request) -> Result<Response> {\n    let mut res = spin_sdk::http::send(\n        http::Request::builder()\n            .method(\"GET\")\n            .uri(\"https://some-random-api.ml/facts/dog\")\n            .body(None)?,\n    )?;\n\n    res.headers_mut()\n        .insert(http::header::SERVER, \"spin/0.1.0\".try_into()?);\n\n    Ok(res)\n}Before we can execute this component, we need to add the some-random-api.ml\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\nallowed_http_hosts = [ \"some-random-api.ml\" ]\n[component.trigger]\nroute = \"/hello\"Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\n{\"fact\":\"It's rumored that, at the end of the Beatles song, \n\\\"A Day in the Life,\\\" Paul McCartney recorded an ultrasonic whistle, \naudible only to dogs, just for his Shetland sheepdog.\"}undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","url":"/spin/rust-components.md#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Redis components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger —\nwhich will connect to a Redis instance and will execute Spin components for\nnew messages on the configured channels.undefinedWriting a Redis component in Rust also takes advantage of the SDK:/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(msg: Bytes) -> Result<()> {\n    println!(\"{}\", from_utf8(&msg)?);\n    Ok(())\n}undefinedundefinedundefinedThe component can be built with Cargo by executing:$ cargo build --target wasm32-wasi --releaseThe manifest for a Redis application must contain the address of the Redis\ninstance the trigger must connect to:spin_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"target/wasm32-wasi/release/spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"This application will connect to redis://localhost:6379, and for every new\nmessage on the messages channel, the echo-message component will be executed.# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin up --file spin.toml\n# the application log file will output the following\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the  messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component we just built, which will emit the println! message to the application log file:INFO spin_redis_engine: Received message on channel \"messages\"\nHello, there!If you would also like to see the println! messages echoed to the console as they happen, please include the additional --follow-all option, when starting the spin application. For example:spin up --file spin.toml --follow-allundefined","url":"/spin/rust-components.md#redis-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Storing data in Redis from Rust components","content":"Using the Spin's Rust SDK, you can use the Redis key/value store and to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Rust SDK to connect to Redis:#[spin_sdk::http_component]\nfn publish(_req: Request) -> Result<Response> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n    let channel = std::env::var(REDIS_CHANNEL_ENV)?;\n\n    // Get the message to publish from the Redis key \"mykey\"\n    let payload = spin_sdk::redis::get(&address, &\"mykey\").map_err(|_| anyhow!(\"Error querying Redis\"))?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka!\"\n    spin_sdk::redis::set(&address, &\"spin-example\", &b\"Eureka!\"[..])\n        .map_err(|_| anyhow!(\"Error executing Redis command\"))?;\n\n    // Publish to Redis\n    match spin_sdk::redis::publish(&address, &channel, &payload) {\n        Ok(()) => Ok(http::Response::builder().status(200).body(None)?),\n        Err(_e) => internal_server_error(),\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","url":"/spin/rust-components.md#storing-data-in-redis-from-rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Using external crates in Rust components","content":"In Rust, Spin components are regular libraries that contain a function\nannotated using the http_component macro, compiled to the\nundefined.\nThis means that any undefined that compiles to wasm32-wasi can\nbe used when implementing the component.","url":"/spin/rust-components.md#using-external-crates-in-rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Troubleshooting","content":"Sometimes things can go wrong, especially such early projects. If you bump into\nissues building and running your Rust component:undefinedundefinedundefinedundefinedundefined","url":"/spin/rust-components.md#troubleshooting"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Manually creating new projects with Cargo","content":"The recommended way of creating new Spin projects is by starting from a template.\nThis section shows how to  manually create a new project with Cargo.When creating a new Spin projects with Cargo, you should use the --lib flag.$ cargo init --libA Cargo.toml with standard Spin dependencies looks like this:[package]\nname = \"your-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# Required to have a `cdylib` (dynamic library) to produce a Wasm module.\ncrate-type = [ \"cdylib\" ]\n\n[dependencies]\n# Useful crate to handle errors.\nanyhow = \"1\"\n# Crate to simplify working with bytes.\nbytes = \"1\"\n# General-purpose crate with common HTTP types.\nhttp = \"0.2\"\n# The Spin SDK.\nspin-sdk = { git = \"https://github.com/fermyon/spin\" }\n# Crate that generates Rust Wasm bindings from a WebAssembly interface.\nwit-bindgen-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", rev = \"cb871cfa1ee460b51eb1d144b175b9aab9c50aba\" }At the time of this writing, wit-bindgen must be pinned to a specific rev.\nThis will change in the future.","url":"/spin/rust-components.md#manually-creating-new-projects-with-cargo"},{"project":"spin","title":"Creating Spin templates","subheading":"","content":"Spin templates allow a Spin developer to quickly create the skeleton of an\napplication or component, ready for the application logic to be filled in.A template consists of two directories, content and metadata.undefinedundefinedFor examples of the directory contents, see the templates directory in the\nundefined.Templates must always be shared in a templates directory.  This allows the\ninstaller to locate them in repos that contain other content.","url":"/spin/template-authoring.md"},{"project":"spin","title":"Creating Spin templates","subheading":"Authoring the content","content":"Copy all the files that you want to be copied as part of the template into\nthe content directory. If you do nothing more, they will be copied\nverbatim. Often, though, you'll want to allow the user to put their own\nvalues in - for example, a project name, or a HTTP route.To do this, replace the text you want the user to be able to substitute\nwith an expression of the form {{parameter-name}}, where parameter-name\nis an identifier of your choice.  undefined - see below.You can reuse a parameter in more than one place - it will be prompted for\nonly once and will get the same value in each place.You can also transform the user value by specifying a filter after a bar:\n{{parameter-name | filter-name}}.  This is particularly useful when you\nwant to conform to specific language conventions. The following filters\nare supported:| Name          | Effect |\n|---------------|--------|\n| kebab_case  | Transforms input into kebab case, e.g. My Application to my-application |\n| snake_case  | Transforms input into snake case, e.g. My Application to my_application |\n| pascal_case | Transforms input into Pascal case, e.g. my appplication to MyApplication |","url":"/spin/template-authoring.md#authoring-the-content"},{"project":"spin","title":"Creating Spin templates","subheading":"Authoring the manifest","content":"The template manifest is a TOML file. It must be named spin-template.toml.manifest_version = \"1\"\nid = \"my-application\"\ndescription = \"An application\"\n\n[parameters]\n# Example parameter\nproject-name = { type = \"string\", prompt = \"Project name\" }undefinedundefinedundefinedThe parameters table is where you list the placeholders that you edited\ninto your content for the user to substitute. You should include an entry\nfor each parameter. The key is the parameter name, and the value a JSON\ndocument that contains at minimum a type and prompt.  type must\ncurrently be string.  prompt is displayed when prompting the user\nfor the value to substitute.The document may also have a default, which will be displayed to the user\nand can be accepted by pressing Enter. It may also specify constraints\non what the user is allowed to enter. The following constraints are\nsupported:| Key           | Value and usage |\n|---------------|-----------------|\n| pattern     | A regular expression. The user input must match the regular expression to be accepted. |","url":"/spin/template-authoring.md#authoring-the-manifest"},{"project":"spin","title":"Creating Spin templates","subheading":"Hosting templates in Git","content":"You can publish templates in a Git repo.  The templates must be in the /templates\ndirectory, with a subdirectory per template.When a user installs templates from your repo, by default Spin looks for a tag\nto identify a compatible version of the templates.  This tag is of the\nform spin/templates/vX.Y, where X is the major version, and Y the minor\nversion, of the user's copy of Spin. For example, if the user is on\nSpin 0.3.1, templates will be installed from spin/templates/v0.3.  If this\ntag does not exist, Spin installs templates from HEAD.","url":"/spin/template-authoring.md#hosting-templates-in-git"},{"project":"spin","title":"Building a URL shortener with Spin","subheading":"","content":"This tutorial will walk you through building a Spin component that\nredirects short URLs to their configured destinations.\nIn essence, this is a simple HTTP component that returns a response that contains\nredirect information based on the user-defined routes.This is an evolving tutorial. As Spin allows building more complex components\n(through supporting access to services like databases), this tutorial will be\nupdated to reflect that.undefinedFirst, our URL shortener allows users to configure their own final URLs —\ncurrently, that is done through a configuration file that contains multiple\n[[route]] entries, each containing the shortened path as source, and\nthe destination URL:[[route]]\nsource = \"/spin\"\ndestination = \"https://github.com/fermyon/spin\"\n\n[[route]]\nsource = \"/hype\"\ndestination = \"https://www.fermyon.com/blog/how-to-think-about-wasm\"Whenever a request for https://<domain>/spin is sent, our component will\nredirect to https://github.com/fermyon/spin. Now that we have a basic\nunderstanding of how the component should behave, let's see how to implement it\nusing Spin.First, we start with undefined:/// A Spin HTTP component that redirects requests \n/// based on the router configuration.\n#[http_component]\nfn redirect(req: Request) -> Result<Response> {\n    let router = Router::default()?;\n    router.redirect(req)\n}All the component does is create a new router based on the default configuration,\nthen use it to redirect the request. Let's see how the router is defined:#[derive(Debug, Deserialize, Serialize)]\npub struct Route {\n    pub source: String,\n    pub destination: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Router {\n    #[serde(rename = \"route\")]\n    pub routes: Vec<Route>,\n}The Router structure is a Rust representation of the TOML configuration above.pub fn redirect(self, req: Request) -> Result<Response> {\n    // read the request path from the `spin-path-info` header\n    let path_info = req\n        .headers()\n        .get(\"spin-path-info\")\n        .expect(\"cannot get path info from request headers\");\n    // if the path is not present in the router configuration,\n    // return 404 Not Found.\n    let route = match self.path(path_info.to_str()?) {\n        Some(r) => r,\n        None => return not_found(),\n    };\n    // otherwise, return the redirect to the destination\n    let res = http::Response::builder()\n        .status(http::StatusCode::PERMANENT_REDIRECT)\n        .header(http::header::LOCATION, route.destination)\n        .body(None)?;\n    Ok(res)\n}The redirect function is straightforward — it reads the request path from the\nspin-path-info header (make sure to read the undefined\nfor an overview of the HTTP headers present in Spin components), selects the\ncorresponding destination from the router configuration, then sends the\nHTTP redirect to the new location.At this point, we can build the module with cargo and run it with Spin:$ cargo build --target wasm32-wasi --release\n$ spin up --file spin.tomlAnd the component can now handle incoming requests:# based on the configuration file, a request\n# to /spin should be redirected\n$ curl -i localhost:3000/spin\nHTTP/1.1 308 Permanent Redirect\nlocation: https://github.com/fermyon/spin\ncontent-length: 0\n# based on the configuration file, a request\n# to /hype should be redirected\n$ curl -i localhost:3000/hype\nHTTP/1.1 308 Permanent Redirect\nlocation: https://www.fermyon.com/blog/how-to-think-about-wasm\ncontent-length: 0\n# /abc is not present in the router configuration,\n# so this returns a 404.\n$ curl -i localhost:3000/abc\nHTTP/1.1 404 Not Found\ncontent-length: 9\n\nNot FoundundefinedWe can now undefined (together\nwith router configuration file):$ spin bindle push --file spin.toml\npushed: url-shortener/1.0.0And now we can run the application directly from the registry:$ spin up --bindle url-shortener/1.0.0In this tutorial we built a simple URL shortener as a Spin component.\nIn the future we will expand this tutorial by storing the router configuration\nin a database supported by Spin, and potentially create another component that\ncan be used to add new routes to the configuration.","url":"/spin/url-shortener.md"}]